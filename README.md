boluj - простой интерпретируемый язык, в данный момент интерпритатор которого существует только на Java.

Багованный и не полный. 

Использовать не рекомендуется.

# Использования библиотеки в своих проектах

Самые основные функции для исполнения кода
```java
Interpreter e = new Interpreter(null);  
//инициализируем стандартный интерпретатор

e.parse(code)                           
//парсим код

BJobject _response = e.exec();          
//выполняем

if(_response.value != "")               
   String result = _response.value;     
//получаем результат

e.clearParsedCode();                   
//очищаем             
```
# Примеры кода

while
```
while:([condition, body]={
?([#($condition)]>[
(#($body)),
( while:(@($condition),@($body)))
]:[0])
});
```
HashMap
```
array~;

array:{
[buf~],
[g:([i]=[$($i)])],
[s:([i,v]=[(buf=($i)),`($buf~),($i=($v)])]
};
```

# Примитивы

number - целочисленные числа

string - стандартные строки

logic - логическое значение

class - класс, имеет внутренний контекст

exception - исключение, не оперируемый тип данных

statement - условный метод, блок кода

function - функция, имеет внутренний контекст

# Синтаксис

Для отделения блоков кода используются предопределенные символы:
```
,
;
)
]
}
(
[
{
    //пробел и/или перенос на новую строку
```
Вы можете использовать любой из этих символов, для вашего удобства. Так-же скобки используются для изменения порядка выполнения:
```
a = (3-6+7)   
// возвращено:  4

a = (3-[6+7]) 
// возвращено: -10
```
К сожалению, из-за некоторых особенностей, Вам нужно будет использовать много скобок. поэтому всё скобки имеют одинаковую функцию:
```
a = {3+(5+6]-6) 
//так делать не рекомендуется, это просто пример
```
Так-же, из-за некоторых особенностей, некоторое выполнение кода может показаться вам странным, к примеру:
```
a = 5+6         
// a = 5, но возвращено будет 11
```
это обусловлено тем, что всё операторы видят ТОЛЬКО ближайший statement и получается что оператор "=" видит только "а" и только "5", поэтому нужно ВСЕГДА использовать скобки:
```
a = (5+6)        
//  а = 11, возвращено 11
```
так-же вы можете вместо названий переменных использовать так-же statement:
```
(a+5)=value      
// a5=value, возвращено value
```
ох, и не стоит забывать, что по названию переменной, значение из неё взять нельзя:
```
a = 5
b = a+1  
//b=a1, возвращено a1
```
так-же довольно важная вещь, что ВСЁ операторы возвращают значение:
```
a = (b+1) = 7  
// a =b1, b1=7, возвращено 7
```
# Контекст

(!) Пожалуйста, читайте этот раздел после прочтения раздела "Операторы"

Контекст или же class - пространство, в котором выполняется код. Бывает текущий контекст и верхний (у верхнего контекста тоже может быть верхний):
```
a=5;
b=3;
c:(a~, a=6)
```
и потом:
```
$a     
// возвращено 5

c:($a) 
// возвращено 6
```
в случае, если в текущем контексте переменная не найдена, она будет искаться в верхнем контексте:
```
c:($b) 
// возвращено 3
```
Но существует проблема контекста - если вы инициализируете переменную, то она создается ТОЛЬКО в текущем контексте. Но эту проблему можно обойти:
```
buf~
s:([i,v]=[(buf=($i)), `($buf~), ($i=($v))])
```
Оператор ` позволяет выполнять код ТОЛЬКО в верхнем контексте. Из-за этого нам понадобилось сделать буфферную переменную в верхнем контексте, записать в неё значение название переменной, которое нужно из нижнего контекста, и инициализировать значение из переменной(название), и после этого только присвоить значение. После этого мы можем вызвать нашу функцию:
```
s:[b,5] 
// b=5, возвращено 5
```
Так или иначе, в классах и функциях контекст одинаковый. В функциях ВСЁ переменные статичные, тоесть:
```
f:([i]={
[?([$b & ""]>[(b~), b=1]):(b=($b)+1)],
[$i+($b)]
})
```
мы создали функцию, которая каждый раз при вызове, увеличивает значение b на 1 и прибавляет это значение ко входящему значению (на убогую проверку или существует переменная b просьба не смотреть). И получается:
```
f:(3) 
//возвращено 5 ибо b=2

f:(3) 
//возрващено 6 ибо b=3

f:(6) 
//возвращено 10 ибо b=4
```
# Операторы

Если вы не понимаете некоторые примеры кода - это нормально
## Оператор инициализации
```
(statement1)~(необязательный statement2)
```
Примеры кода:
```
a~  
s~(javaPath)
```
(!) Инициализирует переменную или класс и возвращает ее.
## Оператор присвоения 
```
statement1 = statement2
```
Примеры кода:
```
b = 3

a = (3+5-($b))

f+($value)=(67*[s:($f)]-3
```
(!)Присваивает значение переменной и возвращает его
## Оператор взятия
```
$statement1
```
Пример кода:
```
$s
$(10-[$f]+b) 
```
(!)Возвращает значение переменной
# Оператор прибавления
```
statement1 + statement2
```
Поддерживаемые типы:
```
string + string
number + number
number + string
string + number
```
# Оператор вычитания
```
statement1 - statement2
```
Поддерживаемые типы:
```
number - number

string - number  
//подрезает строку на number символов
```
## Оператор чтения текстового файла
```
^statement1
```
(!)Возвращает считанные данные из файла по пути statement1
## Функциональный оператор
```
statement1:statement2
```
Есть несколько вариаций для statement2, от которых зависит функционал оператора

кодер слишком ленивый...
